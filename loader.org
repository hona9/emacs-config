#+TITLE: Emacs configuration using org-mode
#+STARTUP: indent 
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction
GNU Emacs org-mode configuration file. Based on Arjen Wiersma's
[[https://gitlab.com/buildfunthings/emacs-config][emacs-config]], Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]], Daniel Mai's [[https://github.com/danielmai/.emacs.d][Mai
Emacs Configuration]] and [[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org][Uncle Dave's Emacs]]. Plus various snippets from the internet.

You can find the latest version of this configuration at
[[https://github.com/maridonkers/emacs-config]].

Disclaimer: tested only (my configuration) on Linux, with emacs 25.1.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Mari Donkers")

(defvar user-emacs-cache-directory
  (concat (getenv "HOME") "/.cache/emacs"))
#+END_SRC
* Installing use-package
** Setup
GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "http://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "http://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "http://stable.melpa.org/packages/"))

;; Add repositories (resetting defaults first).
(setq package-archives nil)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives gnu t)
#+END_SRC

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
(package-initialize)

(unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
             (file-exists-p (concat init-dir "elpa/archives/melpa"))
             (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
        (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+BEGIN_SRC emacs-lisp
(defun packages-install (&rest packages)
  (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC

** The package

#+BEGIN_SRC emacs-lisp
;; Install extensions if they're missing
(defun init--install-packages ()
  (message "Lets install some packages")
  (packages-install
   ;; Since use-package this is the only entry here
   ;; ALWAYS try to use use-package!
   (cons 'use-package melpa)))

(condition-case nil
  (init--install-packages)
  (error (package-refresh-contents)
         (init--install-packages)))
#+END_SRC
** Additionals for use-package
Because use-package supports :diminish and :delight.
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t)
(use-package delight
  :ensure t)
#+END_SRC
* Emacs
** Initialization
- Turn off mouse interface early in startup to avoid momentary display.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Configuration
*** Visit quickly
#+BEGIN_SRC emacs-lisp
(defun config-visit ()
  "Visits ~/.emacs.d/loader.org"
  (interactive)
  (find-file "~/.emacs.d/loader.org"))
(global-set-key (kbd "s-c v") 'config-visit)
#+END_SRC
*** Reload
#+BEGIN_SRC emacs-lisp
(defun config-reload ()
  "Reloads ~/.emacs.d/loader.org at runtime"
  (interactive)
  (org-babel-load-file (expand-file-name "~/.emacs.d/loader.org")))
(global-set-key (kbd "s-c r") 'config-reload)
#+END_SRC
** Menu bar switch
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h") 'menu-bar-mode)
#+END_SRC
** Cursor
*** TODO Set cursor color explicitly
(?) TODO: investigate why this is required
(the cursor doesn't have the correct color otherwise, for
emacsclient).
#+BEGIN_SRC emacs-lisp
(require 'frame)
(defun set-cursor-hook (frame)
  (modify-frame-parameters frame
                           (list (cons 'cursor-color "#ffff00"))))

(add-hook 'after-make-frame-functions 'set-cursor-hook)
#+END_SRC
*** Multiple cursors
The package [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]].
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :diminish multiple-cursors-mode
  :config (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
          (global-set-key (kbd "C-S-SPC") 'mc/edit-lines)
          (global-set-key (kbd "C->") 'mc/mark-next-like-this)
          (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
          (global-set-key (kbd "C-M-S-SPC") 'mc/mark-all-like-this))
#+END_SRC
*** Beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :diminish beacon-mode
  :config
    (beacon-mode 1))
#+END_SRC
** Prerequisite packages
  #+BEGIN_SRC emacs-lisp
  (require 'cl)
  #+END_SRC
** Look and feel
*** Theme
#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
  :ensure t)

(load-theme 'cyberpunk t)

;; To accomodate aging eyes.
(set-face-attribute 'default nil :height 135)

;; Selection color.
;;(set-face-background 'hl-line "#3e4446")
;; (set-face-foreground 'highlight nil)

;; Font size
(define-key global-map (kbd "C-c C-=") 'text-scale-increase)
(define-key global-map (kbd "C-c C--") 'text-scale-decrease)

;; Clearer active window bar.
(set-face-attribute  'mode-line-inactive
                    nil 
                    :foreground "white"
                    :background "#232323"
                    ;; :box '(:line-width 1 :style released-button)
                    :box nil)

(set-face-attribute  'mode-line
                    nil 
                    :foreground "black"
                    :background "darkcyan"
                    ;; :box '(:line-width 1 :style released-button)
                    :box nil)

;; No boxes around mode line (cyberpunk theme creates these).
(set-face-attribute `mode-line nil :box nil)
(set-face-attribute `mode-line-inactive nil :box nil)

;; Set cursor color, shape and no blinking.
(setq-default cursor-color "#ffff00")
(set-cursor-color "#ffff00")
;;(setq-default cursor-type 'hollow)
(blink-cursor-mode 0)
#+END_SRC
*** Sane defaults
[[https://github.com/danielmai/.emacs.d/blob/master/config.org]].
#+BEGIN_SRC emacs-lisp
;; These functions are useful. Activate them.
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)

;; Answering just 'y' or 'n' will do
(defalias 'yes-or-no-p 'y-or-n-p)

;; UTF-8 please
(setq locale-coding-system 'utf-8) ; pretty
(set-terminal-coding-system 'utf-8) ; pretty
(set-keyboard-coding-system 'utf-8) ; pretty
(set-selection-coding-system 'utf-8) ; please
(prefer-coding-system 'utf-8) ; with sugar on top
(setq-default indent-tabs-mode nil)

(setq-default indent-tabs-mode nil)
(setq-default indicate-empty-lines t)

;; Don't count two spaces after a period as the end of a sentence.
;; Just one space is needed.
(setq sentence-end-double-space nil)

;; delete the region when typing, just like as we expect nowadays.
(delete-selection-mode t)

(show-paren-mode t)

(column-number-mode t)

(global-visual-line-mode)
;TODO CHECK ERROR: symbol's function definition is void: diminish
;(diminish 'visual-line-mode)

(setq uniquify-buffer-name-style 'forward)

;; Turn off emacs alarms (those annoying beeps)
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
        '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
#+END_SRC 
*** Desktop
#+BEGIN_SRC emacs-lisp
;; Store desktop (i.e. open files, etc.) at exit (restores when starting again).
(setq desktop-path '("."))
(desktop-save-mode 1)
#+END_SRC
*** Ignore error wrapping
#+BEGIN_SRC emacs-lisp
(defun ignore-error-wrapper (fn)
  "Funtion return new function that ignore errors.
   The function wraps a function with `ignore-errors' macro."
  (lexical-let ((fn fn))
    (lambda ()
      (interactive)
      (ignore-errors
        (funcall fn)))))
#+END_SRC
*** Moving around
**** Bookmarks
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x r <return>") 'bookmark-save)
#+END_SRC
**** Bookmarks (bm)
Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind (("<M-S-return>" . bm-toggle)
         ("<M-S-up>" . bm-previous)
         ("<M-S-down>" . bm-next)))
#+END_SRC
*** Winner mode
#+BEGIN_SRC emacs-lisp
;; Winner mode
;; From: http://www.emacswiki.org/emacs/WinnerMode
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+END_SRC
*** Window swapping
From [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]].
#+BEGIN_SRC emacs-lisp
;; Initialization of these variables is required.
(setq swapping-buffer nil)
(setq swapping-window nil)

;; First call marks window and after switch to second window call
;; again to swap the windows.
(defun swap-buffers-in-windows ()
   "Swap buffers between two windows"
   (interactive)
   (if (and swapping-window
            swapping-buffer)
       (let ((this-buffer (current-buffer))
             (this-window (selected-window)))
         (if (and (window-live-p swapping-window)
                  (buffer-live-p swapping-buffer))
             (progn (switch-to-buffer swapping-buffer)
                    (select-window swapping-window)
                    (switch-to-buffer this-buffer)
                    (select-window this-window)
                    (message "Swapped buffers."))
           (message "Old buffer/window killed.  Aborting."))
         (setq swapping-buffer nil)
         (setq swapping-window nil))
     (progn
       (setq swapping-buffer (current-buffer))
       (setq swapping-window (selected-window))
       (message "Buffer and window marked for swapping."))))

;; Switch windows.
;;(global-set-key (kbd "C-c C-w") 'transpose-windows)
(global-set-key (kbd "C-c C-w") 'swap-buffers-in-windows)

(global-set-key [f9] 'other-window)
#+END_SRC
*** Window moving
#+BEGIN_SRC emacs-lisp
;; Windmove configuration.
(global-set-key (kbd "<s-left>") (ignore-error-wrapper 'windmove-left))
(global-set-key (kbd "<s-right>") (ignore-error-wrapper 'windmove-right))
(global-set-key (kbd "<s-up>") (ignore-error-wrapper 'windmove-up))
(global-set-key (kbd "<s-down>") (ignore-error-wrapper 'windmove-down))

(global-set-key (kbd "C-c <C-left>") (ignore-error-wrapper 'windmove-left))
(global-set-key (kbd "C-c <C-right>") (ignore-error-wrapper 'windmove-right))
(global-set-key (kbd "C-c <C-up>") (ignore-error-wrapper 'windmove-up))
(global-set-key (kbd "C-c <C-down>") (ignore-error-wrapper 'windmove-down))
#+END_SRC
*** Window minimize/maximize
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c -") 'minimize-window)
(global-set-key (kbd "C-c +") 'maximize-window)
#+END_SRC
*** Window resizing
#+BEGIN_SRC emacs-lisp
(defun shrink-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window-horizontally 10))

(defun enlarge-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window-horizontally 10))

(defun shrink-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window 10))

(defun enlarge-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window 10))

;; Window resize bindings.
(global-set-key (kbd "C-S-X <C-S-left>") 'shrink-window-horizontally-stepped)
(global-set-key (kbd "C-S-X <C-S-right>") 'enlarge-window-horizontally-stepped)
(global-set-key (kbd "C-S-X <C-S-down>") 'shrink-window-stepped)
(global-set-key (kbd "C-S-X <C-S-up>") 'enlarge-window-stepped)

(global-set-key (kbd "C-S-C <C-S-left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-S-C <C-S-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-C <C-S-down>") 'shrink-window)
(global-set-key (kbd "C-S-C <C-S-up>") 'enlarge-window)
#+END_SRC
*** Minibuffer
#+BEGIN_SRC emacs-lisp
(defun switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (select-window (active-minibuffer-window))
    (error "Minibuffer is not active")))

;; Switch to minibuffer.
(global-set-key (kbd "C-x M") 'switch-to-minibuffer)
#+END_SRC
*** Ivy, Counsel
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :diminish ivy-mode
  :config (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
          (global-set-key (kbd "C-c C-r") 'ivy-resume)
          (global-set-key (kbd "<f6>") 'ivy-resume))

(use-package counsel
  :ensure t
  :diminish counsel-mode
  :config (global-set-key (kbd "M-x") 'counsel-M-x)
          (global-set-key (kbd "C-x C-f") 'counsel-find-file)
          (global-set-key (kbd "C-x C-S-r") 'counsel-recentf)
          (global-set-key (kbd "<f1> f") 'counsel-describe-function)
          (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
          (global-set-key (kbd "<f1> l") 'counsel-load-library)
          (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
          (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
          (global-set-key (kbd "C-c g") 'counsel-git)
          (global-set-key (kbd "C-c j") 'counsel-git-grep)
          (global-set-key (kbd "C-c a") 'counsel-ag)
          (global-set-key (kbd "C-c l") 'counsel-locate)
          (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
          (define-key read-expression-map (kbd "C-r") 'counsel-expression-history))

(use-package counsel-projectile
  :ensure t
  :diminish counsel-projectile-mode
  :config (counsel-projectile-mode))
#+END_SRC
*** Mark
**** Selection
#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

;; Mark without select visible.
(global-set-key (kbd "C-`") 'push-mark-no-activate)
(global-set-key (kbd "C-~") 'jump-to-mark)
#+END_SRC
**** Convenience mapping for navigating back to your previous editing spots
#+BEGIN_SRC emacs-lisp
;; Does C-U C-SPC programatically.
(defun set-mark-command-prefix-arg ()
  (interactive)
  (setq current-prefix-arg '(4)) ; C-u
  (call-interactively 'set-mark-command))

(global-set-key (kbd "<s-SPC>") 'set-mark-command-prefix-arg)
#+END_SRC
*** Tabs
#+BEGIN_SRC emacs-lisp
;; Tab indentation width.
(setq tab-width 4)
#+END_SRC
*** Speedbar
#+BEGIN_SRC emacs-lisp
(global-set-key [f11] 'speedbar)
#+END_SRC
*** Default browser
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-chromium)
#+END_SRC
** Break & Debug
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-g") 'top-level)
; (toggle-debug-on-quit)
#+END_SRC
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC
** Revert buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-M-f") 'revert-buffer)
#+END_SRC
** Large files
#+BEGIN_SRC emacs-lisp
;; Large files slow emacs down to a grind. Main offender is fundamental mode.
(defun my-find-file-check-make-large-file-read-only-hook ()
  "If a file is over a given size, make the buffer read only."
  (when (> (buffer-size) (* 1024 1024))
    ;;(setq buffer-read-only t)
    ;;(buffer-disable-undo)
    (fundamental-mode)))

(add-hook 'find-file-hook 'my-find-file-check-make-large-file-read-only-hook)
#+END_SRC
** Disable auto save and -backup
#+BEGIN_SRC emacs-lisp
;disable backup
(setq backup-inhibited t)
;disable auto save
(setq auto-save-default nil)
#+END_SRC
** sudo-edit
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :ensure t
  :bind
    ("s-e" . sudo-edit))
#+END_SRC
** async
#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :init (dired-async-mode 1))
#+END_SRC
** dmenu
#+BEGIN_SRC emacs-lisp
(use-package dmenu
  :ensure t)
(global-set-key (kbd "C-c d") 'dmenu)
#+END_SRC
** Default browser
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "google-chrome")
#+END_SRC
** Follow created window
[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
** Swiper
Retrying Swiper (is it now faster with big files?)
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-s" . 'swiper))
(global-set-key (kbd "M-s s") 'isearch-forward)
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
;; (setq ibuffer-expert t)
#+END_SRC
** Kill current buffer
https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC
** Kill all buffers
https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org
#+BEGIN_SRC emacs-lisp
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC
** Kill ring
*** Size
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 100)
#+END_SRC
*** Clear
#+BEGIN_SRC emacs-lisp
(defun clear-kill-ring ()
  (interactive)
  (setq kill-ring nil)
  (garbage-collect))
(global-set-key (kbd "s-y") 'clear-kill-ring)
#+END_SRC
*** popup-kill-ring
#+BEGIN_SRC emacs-lisp
(use-package popup-kill-ring
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC
** Bash
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
(global-set-key (kbd "C-c t") 'ansi-term)
#+END_SRC
** Time
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %d %B %Y")
(display-time-mode 1)
#+END_SRC
** Alsa
*** Volume controls
This appears to be done by the =desktop-environment= package.
#+BEGIN_COMMENT
#+BEGIN_SRC emacs-lisp
(defun audio/mute ()
  (interactive)
  (start-process "audio-mute" nil "amixer" "-q" "sset" "Master" "toggle"))

(defun audio/raise-volume ()
  (interactive)
  (start-process "raise-volume" nil "amixer" "-q" "sset" "Master" "10%+"))

(defun audio/lower-volume ()
  (interactive)
(start-process "lower-volume" nil "amixer" "-q" "sset" "Master" "10%-"))

(global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
(global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
(global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
#+END_SRC
#+END_COMMENT
** Screen lock, Suspend and Hibernate
Beware: the =light-locker= daemon must be running for the screen locking to work.
#+BEGIN_SRC emacs-lisp
(defun light-lock-screen ()
  (interactive)
  (shell-command "light-locker-command -l"))
(global-set-key (kbd "<Scroll_Lock>") #'light-lock-screen)

(defun systemctl-suspend ()
  (interactive)
  (shell-command "systemctl suspend"))
(exwm-input-set-key (kbd "C-<Scroll_Lock>") #'systemctl-suspend)
(global-set-key (kbd "<XF86ScreenSaver>") #'systemctl-suspend)

(defun systemctl-hibernate ()
  (interactive)
  (shell-command "systemctl hibernate"))
(global-set-key (kbd "C-M-<Scroll_Lock>") #'systemctl-hibernate)
#+END_SRC
* exwm
** Emacs Window Manager
Remove comments for =exwm= (which is very nice indeed, but I'm afraid
it'll give me carpal tunnel syndrome; too late, I'm already addicted to it).

Wiki: [[https://github.com/ch11ng/exwm/wiki][EXWM wiki]].
#+BEGIN_SRC emacs-lisp
(use-package exwm
  :ensure t
  :config

    ;; necessary to configure exwm manually
    (require 'exwm-config)

    ;; fringe size, most people prefer 1 
    (fringe-mode 3)
    
    ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
    (server-start)

    ;; this fixes issues with ido mode (e.g. dmenu not fully showing), if you use helm, get rid of it
    (exwm-config-ido)

    ;; a number between 1 and 9, exwm creates workspaces dynamically; start out with 2 (multiple monitor).
    (setq exwm-workspace-number 2)

    ;; Workspaces.
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    ;; reize windows with mouse.
    (setq window-divider-default-right-width 1)
    (window-divider-mode)

    ; Rename buffer to window title (Otherwise EXWM#).
    (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
    (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)

    ;; this is a way to declare truly global/always working keybindings
    ;; this is a nifty way to go back from char mode to line mode without using the mouse
    (exwm-input-set-key (kbd "s-x") #'exwm-reset)
    (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
    (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
    (exwm-input-set-key (kbd "s-s") #'exwm-workspace-swap)
    (exwm-input-set-key (kbd "s-b") #'exwm-workspace-switch-to-buffer)
    (exwm-input-set-key (kbd "s-m") #'exwm-workspace-move-window)
    (exwm-input-set-key (kbd "C-c x") #'exwm-randr-refresh)

    ;; the next loop will bind s-<number> to switch to the corresponding workspace
    (dotimes (i 10)
      (exwm-input-set-key (kbd (format "s-%d" i))
                          `(lambda ()
                             (interactive)
                             (exwm-workspace-switch-create ,i))))

    ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
    (exwm-input-set-key (kbd "s-&")
                        (lambda (command)
                          (interactive (list (read-shell-command "$ ")))
                          (start-process-shell-command command nil command)))

    ;; an easy way to make keybindings work *only* in line mode
    (push ?\C-q exwm-input-prefix-keys)
    (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

    ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
    (exwm-input-set-simulation-keys
     '(
       ;; movement
       ([?\C-b] . left)
       ([?\M-b] . C-left)
       ([?\C-f] . right)
       ([?\M-f] . C-right)
       ([?\C-p] . up)
       ([?\C-n] . down)
       ([?\C-a] . home)
       ([?\C-e] . end)
       ([?\M-v] . prior)
       ([?\C-v] . next)
       ([?\C-d] . delete)
       ([?\C-k] . (S-end delete))
       ;; cut/paste
       ([?\C-w] . ?\C-x)
       ([?\M-w] . ?\C-c)
       ([?\C-y] . ?\C-v)
       ;; search
       ([?\C-s] . ?\C-f)))

    ;; Commented out because desktop-environment package apparently supplies this.
    ;; this little bit will make sure that XF86 keys work in exwm buffers as well
    ;(dolist (k '(XF86AudioLowerVolume
    ;           XF86AudioRaiseVolume
    ;           XF86PowerOff
    ;           XF86AudioMute
    ;           XF86AudioPlay
    ;           XF86AudioStop
    ;           XF86AudioPrev
    ;           XF86AudioNext
    ;           XF86ScreenSaver
    ;           XF68Back
    ;           XF86Forward
    ;           Scroll_Lock
    ;           print))
    ;(cl-pushnew k exwm-input-prefix-keys))

    ;(setq exwm-randr-workspace-output-plist '(0 "LVDS-1" 1 "HDMI-1"))
)

;;TODO! Only if in EXWM desktop check if environment variable DESKTOP_SESSION=exwm
;; this just enables exwm, it started automatically once everything is ready
(require 'exwm-systemtray)
(exwm-systemtray-enable)

(require 'exwm-randr)
(setq exwm-randr-workspace-output-plist '(0 "LVDS-1" 1 "HDMI-1"))
(add-hook 'exwm-randr-screen-change-hook
      (lambda ()
        (start-process-shell-command
         "xrandr" nil "xrandr --output HDMI-1 --primary --auto --output LVDS-1 --auto --right-of HDMI-1")))
;;TODO! Only if in EXWM desktop check if environment variable DESKTOP_SESSION=exwm
(exwm-randr-enable)

;;TODO! Only if in EXWM desktop check if environment variable DESKTOP_SESSION=exwm
(exwm-enable)
#+END_SRC
** desktop-environment
Extension package for e.g. volume keys and screen lock with s-l.
#+BEGIN_SRC emacs-lisp
(use-package desktop-environment
  :diminish desktop-environment-mode
  :ensure t
  :config (if window-system
            (desktop-environment-mode)))
#+END_SRC
** Battery monitor
#+BEGIN_SRC emacs-lisp
(use-package fancy-battery
  :ensure t
  :config
    (setq fancy-battery-show-percentage t)
    (setq battery-update-interval 15)
    (if window-system
      (fancy-battery-mode)
      (display-battery-mode)))
#+END_SRC
** System monitor
#+BEGIN_SRC emacs-lisp
(use-package symon
  :ensure t
  :diminish symon-mode
  :config (symon-mode)
  :bind
  ("s-h" . symon-mode))
#+END_SRC
* Org-mode
Org-mode is an Emacs built-in.
** TODO Shortcuts
#+BEGIN_SRC emacs-lisp
;;TODO
;;(require 'org)
;;(define-key global-map "\C-cl" 'org-store-link)
;;(define-key global-map "\C-ca" 'org-agenda)
;;(setq org-log-done t)

(define-key org-mode-map (kbd "<C-M-tab>") 'pcomplete)
#+END_SRC
** org-bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :diminish org-bullets-mode
  :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC
** Exports
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :ensure t)
#+END_SRC
** Indentation
#+BEGIN_SRC emacs-lisp
;TODO CHECK ERROR: symbol's function definition is void: diminish
;(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
** HTMLize buffers
When exporting documents to HTML documents, such as code fragments, we need to htmlize.
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC
** TODO Reveal.js
Tool to create presentations via an emacs org file export. See: [[https://github.com/emacsmirror/org-re-reveal]].
#+BEGIN_COMMENT
#+BEGIN_SRC emacs-lisp
;;TODO doesn't appear to work (breaks org-mode export of title sections).
(use-package org-re-reveal
  :ensure t)

;; Reveal.js location and ox-reveal.
;;(setq org-reveal-root "file:///home/mdo/lib/reveal.js")
;;(setq org-reveal-mathjax t)
#+END_SRC
#+END_COMMENT
* Edit indirect
The edit-indirect package is used by Markdown for editing code blocks.
#+BEGIN_SRC emacs-lisp
(use-package edit-indirect
  :ensure t)
#+END_SRC
* Markdown
Markdown is a great way to write documentation, not as good as
org-mode of course, but generally accepted as a standard.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC
* AsciiDoc
[[http://www.methods.co.nz/asciidoc/][AsciiDoc]] is an alternative way to write documentation, not as good as
org-mode of course, but supported by e.g. github. The [[https://github.com/sensorflo/adoc-mode/wiki][adoc-mode]] Emacs
major mode supports the adoc format.
#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)

(add-to-list 'auto-mode-alist (cons "\\.adoc\\'" 'adoc-mode))
(add-hook 'adoc-mode-hook (lambda() (buffer-face-mode t)))
#+END_SRC
* LaTex
#+BEGIN_SRC emacs-lisp
(use-package tex
    :ensure auctex
    :config (setq TeX-auto-save t)
            (setq TeX-parse-self t)
            (setq TeX-save-query nil))
;;(setq TeX-PDF-mode t)
(require 'tex)
#+END_SRC
* Programming
** General
Setup for GNU Emacs, Clojure and ClojureScript. Plus [[https://github.com/Fuco1/smartparens][Smartparens]].

The structured editing of smartparens is useful in a LOT of languages, as
long as there are parenthesis, brackets or quotes.
*** Utilities
String manipulation routines for emacs lisp
#+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
#+END_SRC
*** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config (progn (show-smartparens-global-mode t))
                 (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-strict-mode)
                 (add-hook 'ielm-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-interaction-mode-hook #'smartparens-strict-mode)
                 (add-hook 'scheme-mode-hook #'smartparens-strict-mode)
  :bind (("<f7>" . smartparens-strict-mode)
         ("C-S-s a" . sp-beginning-of-sexp)
         ("C-S-s e" . sp-end-of-sexp)
         ("C-S-s d" . sp-down-sexp)
         ("C-S-s u" . sp-up-sexp)
         ("C-S-s D" . sp-backward-down-sexp)
         ("C-S-s U" . sp-up-down-sexp)
         ("C-S-s f" . sp-forward-sexp)
         ("C-S-s b" . sp-backward-sexp)
         ("C-M-<right>" . sp-next-sexp)
         ("C-M-<left>" . sp-previous-sexp)
         ("C-S-s S" . sp-backward-symbol)
         ("C-S-s s" . sp-forward-symbol)
         ("C-S-s |" . sp-split-sexp)
         ("C-S-s U" . sp-backward-unwrap-sexp)
         ("C-S-s u" . sp-unwrap-sexp)
         ("M-<right>" . sp-forward-slurp-sexp)
         ("M-S-<right>" . sp-forward-barf-sexp)
         ("M-<left>" . sp-backward-slurp-sexp)
         ("M-S-<left>" . sp-backward-barf-sexp)
         ("C-S-s t" . sp-transpose-sexp)
         ("C-S-s k" . sp-kill-sexp)
         ("C-S-s h" . sp-kill-hybrid-sexp)
         ("C-S-s K" . sp-backward-kill-sexp)))
#+END_SRC
*** Highlight parentheses
#+BEGIN_SRC emacs-lisp
(use-package highlight-parentheses
  :ensure t
  :diminish highlight-parentheses-mode
  :config (add-hook 'emacs-lisp-mode-hook
            (lambda() (highlight-parentheses-mode))))

(global-highlight-parentheses-mode)
#+END_SRC
*** Rainbow
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :diminish rainbow-mode
  :init
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
*** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :diminish rainbow-delimiters-mode
  :config (add-hook 'lisp-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojure-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojurec-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojurescript-mode-hook
              (lambda() (rainbow-delimiters-mode))))

(global-highlight-parentheses-mode)
#+END_SRC

*** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config (yas/global-mode 1)
          (add-to-list 'yas-snippet-dirs (concat init-dir "snippets"))
          (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'html-mode)))
          (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'css-mode))))

(use-package clojure-snippets
  :ensure t)
#+END_SRC
*** Auto completion
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :bind (("<C-M-return>" . company-complete))
  :config (global-company-mode))

;;  (use-package company-flx
;;    :ensure t
;;    :config (with-eval-after-load 'company
;;            (company-flx-mode +1)))
#+END_SRC
*** TODO Auto completion for web
Taken from: [[https://github.com/aiguofer/.emacs.d/blob/master/init.el]].
#+BEGIN_SRC emacs
; (use-package company-web
;     :ensure t
;     :commands (company-web-html))
#+END_SRC
Disabled because it no longer works. Error message as follows: =Company backend ’company-web-html’ could not be initialized: Symbol’s function definition is void: company-web-html=
*** Code folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :diminish origami-mode
  :config (global-origami-mode)
  :bind (("C-c |" . origami-reset)
         ("C-c {" . origami-open-node-recursively)
         ("C-c }" . origami-close-node-recursively)
         ("C-c \"" . origami-toggle-all-nodes)))
#+END_SRC
*** Version Control
Magit is the only thing you need when it comes to Version Control (Git)

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
;; Project based navigation and search. Note also the .projectile file that
;; can be placed in the root of a project. It can be used to exclude (or include)
;; directories (see: https://github.com/bbatsov/projectile).
(use-package projectile
  :ensure t
  :diminish projectile-mode)

(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC
*** REST (client) support
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t)
#+END_SRC

*** Imenu
#+BEGIN_SRC emacs-lisp
;; Add imenu to menu bar and make it automatically rescan.
(add-hook 'clojure-mode-hook #'imenu-add-menubar-index)
(add-hook 'clojurec-mode-hook #'imenu-add-menubar-index)
(add-hook 'clojurescript-mode-hook #'imenu-add-menubar-index)
(setq imenu-auto-rescan 1)

;; Incremental imenu.
(global-set-key (kbd "C-S-l") 'imenu)
#+END_SRC
*** Symbols
**** TODO Highlight s-exp
#+BEGIN_SRC emacs-lisp
; (use-package hl-sexp
;   :ensure t
;   :config (add-hook 'lisp-mode-hook #'hl-sexp-mode)
;           (add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode) 
;   :bind (("C-M-'" . hl-sexp-mode)))
#+END_SRC
**** Highlight symbol
Global highlight code taken from [[https://github.com/nschum/highlight-symbol.el/issues/11]].
#+BEGIN_SRC emacs-lisp
(defun highlight-symbol-mode-on () (highlight-symbol-mode 1))
(define-globalized-minor-mode global-highlight-symbol-mode
                              highlight-symbol-mode
                              highlight-symbol-mode-on)

(use-package highlight-symbol
  :ensure t
  :diminish highlight-symbol-mode
  :config (setq highlight-symbol-idle-delay  0.5)
  :bind (("C-*" . highlight-symbol)
         ("M-*" . highlight-symbol-remove-all)
         ("<f5>" . highlight-symbol-next)
         ("S-<f5>" . highlight-symbol-prev)
         ("M-<f5>" . highlight-symbol-query-replace)))

;;WARNING: interferes with Magit faces. (do not use global mode).
;;(global-highlight-symbol-mode 1)
#+END_SRC
*** Re-map xref keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-.") 'xref-find-definitions)
(global-set-key (kbd "C-M-,") 'xref-pop-marker-stack)
#+END_SRC
*** Dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :diminish dumb-jump-mode
  :bind (("C-." . dumb-jump-go)
         ("C-," . dumb-jump-back)))
#+END_SRC
*** hl-line
#+BEGIN_SRC emacs-lisp
(when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
** Flycheck syntax checker
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode)
(add-hook 'prog-mode-hook #'flycheck-mode)
#+END_SRC
** Clojure
The clojure ecosystem for GNU Emacs consists out of CIDER and bunch of
supporting modules.
*** Cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :diminish cider-mode
  :pin melpa-stable
  :init (setq cider-show-error-buffer t
              cider-auto-select-error-buffer t
              ;;cider-repl-pop-to-buffer-on-connect nil
              cider-repl-use-clojure-font-lock t
              cider-repl-wrap-history t
              cider-repl-history-file "~/.emacs.d/cider-history"
              cider-repl-history-size 999
              cider-repl-use-pretty-printing t
              nrepl-hide-special-buffers t
              ;; Stop error buffer from popping up while working in buffers other than the REPL:
              nrepl-popup-stacktraces nil)

        (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
        (add-hook 'cider-repl-mode-hook #'company-mode)
        (add-hook 'cider-mode-hook #'company-mode)
        (add-hook 'cider-mode-hook #'eldoc-mode)

;;  :config (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
;;          (add-hook 'cider-repl-mode-hook #'company-mode)
;;          (add-hook 'cider-mode-hook #'company-mode)
;;          (add-hook 'cider-mode-hook #'eldoc-mode)            
;;          (setq cider-repl-history-file "~/.emacs.d/cider-history")
;;          (setq cider-repl-use-clojure-font-lock t)
;;          (setq cider-repl-result-prefix ";; => ")
;;          (setq cider-repl-wrap-history t)
;;          (setq cider-repl-history-size 9999)
;;          (setq cider-repl-use-pretty-printing t)
;;          (setq cider-repl-display-help-banner nil)
;;          ;(setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")

  :bind (("M-r" . cider-namespace-refresh)
         ("C-c r" . cider-repl-reset)
         ("C-c ." . cider-reset-test-run-tests)
         ("C-c C-v C-e" . cider-eval-defun-at-point)
         ;("M-<return>" . cider-doc)
         ("<f8>" . cider-clear-compilation-highlights)))

(require 'clojure-mode)
(define-key clojure-mode-map (kbd "M-<return>") 'cider-doc)

(add-hook 'clojure-mode-hook #'smartparens-strict-mode)
(add-hook 'clojurec-mode-hook #'smartparens-strict-mode)
(add-hook 'clojurescript-mode-hook #'smartparens-strict-mode)
(add-hook 'clojure-mode-hook #'highlight-symbol-mode)
#+END_SRC
*** Flycheck-joker
#+BEGIN_SRC emacs-lisp
(use-package flycheck-joker
  :ensure t
  :diminish flycheck-joker-mode)
#+END_SRC
*** clj-refactor
#+BEGIN_SRC emacs-lisp
(use-package clj-refactor
  :ensure t
  :diminish clj-refactor-mode
  :init
  (add-hook 'clojure-mode-hook 'clj-refactor-mode)
  :config
  ;; Configure the Clojure Refactoring prefix:
  (cljr-add-keybindings-with-prefix "C-c C-/")
  :diminish clj-refactor-mode)
#+END_SRC
*** Expand region
#+BEGIN_SRC emacs-lisp
;expand-region functionality is really great for lisp/clojure editing
;from https://github.com/magnars/expand-region.el
(use-package expand-region
  :ensure t
  :bind ("s-r" . er/expand-region))
#+END_SRC
*** Sayid
[[http://bpiel.github.io/sayid/][Sayid]] (siy EED) is a tool for debugging and profiling clojure code.

Sayid works by intercepting and recording the inputs and outputs of functions. It can even record function calls that occur inside of functions. The user can select which functions to trace. Functions can be selected individually or by namespace. The recorded data can be displayed, queried and profiled.
#+BEGIN_SRC emacs-lisp
;; http://bpiel.github.io/sayid/
(use-package sayid
  :ensure t)

(eval-after-load 'clojure-mode
   '(sayid-setup-package))
#+END_SRC
** Geiser
[[http://www.nongnu.org/geiser/][Geiser]] is a collection of Emacs major and minor modes that conspire with one or more Scheme interpreters to keep the Lisp Machine Spirit alive. It draws inspiration (and a bit more) from environments such as Common Lisp’s Slime, Factor’s FUEL, Squeak or Emacs itself, and does its best to make Scheme hacking inside Emacs (even more) fun.

#+BEGIN_SRC emacs-lisp
(use-package geiser
  :ensure t)
#+END_SRC
** TODO PHP
Let's get some of that low hanging fruit...

Use the packages listed for [[https://github.com/emacs-php/php-suite][php-suite]].

Create a Docker container for PHP and the required tooling to prevent system pollution.
*** Php-runtime
#+BEGIN_SRC emacs-lisp
(use-package php-runtime
  :ensure t)
#+END_SRC
*** TODO [[https://github.com/ejmr/php-mode][php-mode]]
#+BEGIN_SRC emacs-lisp
(use-package php-mode
;  :pin melpa-stable
  :ensure t)

; http://ergoemacs.org/emacs/emacs_set_default_browser.html
;; See above under [[Emacs][Emacs]]
;;(setq browse-url-browser-function 'eww-browse-url)
;; "etags `find . \\( -name '*.php' -o -name '*.sql' \\)`"
;; "etags TAGS `git ls-files | egrep '*.(php|sql)'`"
#+END_SRC
*** TODO php-extras
#+BEGIN_SRC emacs-lisp
;;(use-package php-extras
;;  :ensure t)
#+END_SRC
*** Composer
#+BEGIN_SRC emacs-lisp
(use-package composer
  :ensure t)
#+END_SRC
*** Phpunit
#+BEGIN_SRC emacs-lisp
(use-package phpunit
  :ensure t)
#+END_SRC
*** Phpactor
#+BEGIN_SRC emacs-lisp
(use-package phpactor
  :ensure t)
#+END_SRC
*** Psysh
#+BEGIN_SRC emacs-lisp
(use-package psysh
  :ensure t)
#+END_SRC
*** Phpstan
#+BEGIN_SRC emacs-lisp
(use-package phpstan
  :ensure t)
(use-package flycheck-phpstan
  :ensure t)
#+END_SRC
*** Auto completion for phpactor
#+BEGIN_SRC emacs-lisp
(use-package company-phpactor
  :ensure t)
#+END_SRC
*** Snippets for PHP
#+BEGIN_SRC emacs-lisp
(use-package php-auto-yasnippets
  :pin melpa-stable
  :ensure t)
(require 'php-auto-yasnippets)
(setq php-auto-yasnippet-php-program "~/.emacs.d/elpa/php-auto-yasnippets-2.3.1/Create-PHP-YASnippet.php")
(define-key php-mode-map (kbd "C-c C-y") 'yas/create-php-snippet)
#+END_SRC
** Rust
rust-mode
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :pin melpa-stable
  :ensure t)
#+END_SRC
** Julia
julia-mode
#+BEGIN_SRC emacs-lisp
(use-package julia-mode
  :ensure t)
#+END_SRC
** TypeScript
#+BEGIN_SRC emacs
(use-package typescript-mode
  :ensure t
  :mode "\\.ts\\'")
#+END_SRC
** SCSS
scss mode
#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t)
#+END_SRC
** HTML
*** TODO [[http://web-mode.org/][Web mode]]
#+BEGIN_SRC emacs-lisp
(use-package web-mode
;  :pin melpa-stable
  :ensure t
  :mode (("\\.erb\\'" . web-mode)
	 ("\\.mustache\\'" . web-mode)
	 ("\\.html?\\'" . web-mode)
	 ("\\.scss\\'" . web-mode)
	 ("\\.css\\'" . web-mode)
	 ("\\.js\\'" . web-mode)
	 ("\\.vue\\'" . web-mode)
   ("\\.blade\\.php\\'" . web-mode))
  :config (progn
            (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 4))
          (add-hook 'web-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'web-beautify-html-buffer t t)
              ;; (add-hook 'after-save-hook 'web-mode-reload t t)
              )))
#+END_SRC
*** [[https://github.com/smihica/emmet-mode][Emmet mode]]
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
:ensure t
:diminish emmet-mode
:config (add-hook 'clojure-mode-hook 'emmet-mode)
        (add-hook 'web-mode-hook 'emmet-mode)
        (add-hook 'php-mode-hook 'emmet-mode))
#+END_SRC
* Docker
Docker modes (file and compose).
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :pin melpa-stable
  :ensure t)

(use-package docker-compose-mode
  :pin melpa-stable
  :ensure t)
#+END_SRC
* Editing
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
    ("C-c c" . avy-goto-char))
#+END_SRC
** Words
*** Improved kill-word
Why on earth does a function called kill-word not .. kill a word. It instead deletes characters from your cursors position to the end of the word, let’s make a quick fix and bind it properly.

[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC
*** Improved copy-word
And again, the same as above but we make sure to not delete the source word.

[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Navigation one hand shortcuts
#+BEGIN_SRC emacs-lisp
;; Delete sexp.
(global-set-key (kbd "<C-s-left>") 'previous-buffer)
(global-set-key (kbd "<C-s-right>") 'next-buffer)
#+END_SRC
** Navigation and S-exp
#+BEGIN_SRC emacs-lisp
;; Delete sexp.
(global-set-key (kbd "<C-S-delete>") 'kill-sexp)

;; Goto previous top level paren-block.
(global-set-key (kbd "M-p") 'outline-previous-visible-heading)
(global-set-key (kbd "M-n") 'outline-next-visible-heading)

;; C-arrow for word navigation.
(global-set-key (kbd "<C-left>") 'left-word)
(global-set-key (kbd "<C-right>") 'right-word)

;; Convenience key mappings for sexp navigation.
(global-set-key (kbd "C-x <left>") 'sp-backward-sexp)
(global-set-key (kbd "C-S-x <left>") 'sp-backward-up-sexp)
(global-set-key (kbd "C-x <right>") 'sp-forward-sexp)

;; Bury buffer (moves to end of buffer list).
(global-set-key (kbd "M-B") 'bury-buffer)
#+END_SRC
** Lines
*** Selecting
#+BEGIN_SRC emacs-lisp
(defun select-current-line ()
  "Select current line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2015-02-07
"
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))

;; Select current line.
(global-set-key (kbd "C-|") 'select-current-line)
#+END_SRC
*** Joining
#+BEGIN_SRC emacs-lisp
(defun join-next-line ()
  "Join next line."
  (interactive)
  (forward-line 1)
  (join-line))

;; Join line.
(global-set-key (kbd "C-S-J") 'join-next-line)
#+END_SRC
*** Deleting
#+BEGIN_SRC emacs-lisp
(defun delete-line-or-region (&optional n)
  "Delete current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
	(delete-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
	(delete-region (line-beginning-position) (line-end-position))
	(kill-whole-line)))))

;; Delete region.
(global-set-key (kbd "C-S-D") 'delete-line-or-region)
(global-set-key (kbd "<M-delete>") 'delete-line-or-region)
#+END_SRC
*** TODO Commenting
Instead of this check out [[https://github.com/yuutayamada/commenter][commenter]] package.
#+BEGIN_SRC emacs-lisp
(defun comment-line-or-region (&optional n)
  "Comment current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
	(comment-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
	(comment-region (line-beginning-position) (line-end-position))))))

;; Comment current line or region.
(global-set-key (kbd "C-;") 'comment-line-or-region)
#+END_SRC
*** Move-dup
#+BEGIN_SRC emacs-lisp
(use-package move-dup
  :ensure t)

;; Global mode or text-mode-hook interferes with e.g. org-mode M-down and M-up.
;;(global-move-dup-mode)
;;(add-hook 'text-mode-hook 'move-dup-mode)

(add-hook 'clojure-mode-hook (lambda () (move-dup-mode)))
(add-hook 'clojurescript-mode-hook (lambda () (move-dup-mode)))
(add-hook 'lisp-mode-hook (lambda () (move-dup-mode)))
(add-hook 'sql-mode-hook (lambda () (move-dup-mode)))
(add-hook 'c-mode-hook (lambda () (move-dup-mode)))
(add-hook 'sh-mode-hook (lambda () (move-dup-mode)))
(add-hook 'python-mode-hook (lambda () (move-dup-mode)))
(add-hook 'perl-mode-hook (lambda () (move-dup-mode)))
(add-hook 'php-mode-hook (lambda () (move-dup-mode)))
(add-hook 'markdown-mode-hook (lambda () (move-dup-mode)))
(add-hook 'xml-mode-hook (lambda () (move-dup-mode)))
(add-hook 'html-mode-hook (lambda () (move-dup-mode)))
(add-hook 'web-mode-hook (lambda () (move-dup-mode)))
#+END_SRC
*** Truncating
#+BEGIN_SRC emacs-lisp
;; Disable line truncating by default (normally buffer local setting)
(set-default 'truncate-lines t)
#+END_SRC
*** Numbering
#+BEGIN_SRC emacs-lisp
;; No line numbers by default.
(global-linum-mode 0)
(set-default 'global-linum-mode 0)

;; Line numbers for programming.
(add-hook 'prog-mode-hook (lambda () (linum-mode 1)))
;(add-hook 'web-mode-hook (lambda () (linum-mode 1)))
#+END_SRC

*** Various
#+BEGIN_SRC emacs-lisp
;; Quick switch linum-mode.
(global-set-key (kbd "C-S-n") 'linum-mode)

;; Expand and replace region.
(global-set-key (kbd "C-$") 'expand-delete-line)

;; Turn off text wrapping in the middle of a word
(global-visual-line-mode 1)
#+END_SRC
** Change
*** Goto last change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure t)

(global-set-key (kbd "C-S-Q") 'goto-last-change)
#+END_SRC
*** Undo tree
#+BEGIN_SRC emacs-lisp
;; Adds a custom directory where some .el scripts are placed used in
;; this config file. Note that if you have .el scripts that exist on
;; Melpa, you don't need this directory. But I have an undo-tree
;; script (configured below) not on Melpa, so this is how you do it:
(add-to-list 'load-path (concat user-emacs-directory "macros-config"))

;; From http://www.emacswiki.org/emacs/UndoTree Script must exist in
;; the macros-config directory before proceeding (see above paragraph)
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :config (global-undo-tree-mode))

;; Replace regular undo and redo with respectively tree-undo and tree-redo.
(global-set-key (kbd "C-_") 'undo-tree-undo)
(global-set-key (kbd "C-/") 'undo-tree-undo)
(global-set-key (kbd "C-z") 'undo-tree-undo)

(global-set-key (kbd "M-_") 'undo-tree-redo)
(global-set-key (kbd "C-?") 'undo-tree-redo)
(global-set-key (kbd "C-S-Z") 'undo-tree-redo)

;; Undo tree visualize
(global-set-key (kbd "C-x u") 'undo-tree-visualize)
#+END_SRC
** Parenthesis
*** Matching
Emacs lisp code from: [[https://www.emacswiki.org/emacs/NavigatingParentheses][Navigating Parentheses]].
#+BEGIN_SRC emacs-lisp
(defun goto-match-paren (arg)
  "Go to the matching parenthesis if on parenthesis. Else go to the
   opening parenthesis one level up."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1))
	(t
	 (backward-char 1)
	 (cond ((looking-at "\\s\)")
		(forward-char 1) (backward-list 1))
	       (t
		(while (not (looking-at "\\s("))
		  (backward-char 1)
		  (cond ((looking-at "\\s\)")
			 (message "->> )")
			 (forward-char 1)
			 (backward-list 1)
			 (backward-char 1)))
		  ))))))

(global-set-key (kbd "C-S-P") 'goto-match-paren)
#+END_SRC
** Whitespaces
#+BEGIN_SRC emacs-lisp
;; Trim trailing whitespaces in current buffer.
(global-set-key (kbd "C-S-W") 'delete-trailing-whitespace)
#+END_SRC
** Search
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-S-F") 'find-dired)
(global-set-key (kbd "C-%") 'replace-string)

(use-package ag
  :ensure t
  :diminish ag-mode)
#+END_SRC
** Scroll
#+BEGIN_SRC emacs-lisp
;; Scroll without changing point.
(global-set-key (kbd "s-<") 'scroll-right)
(global-set-key (kbd "s->") 'scroll-left)

(global-set-key (kbd "<C-up>") 'backward-paragraph)
(global-set-key (kbd "<C-down>") 'forward-paragraph)
(global-set-key (kbd "<s-S-up>") 'scroll-up-line)
(global-set-key (kbd "<s-S-down>") 'scroll-down-line)
#+END_SRC
** Backup
#+BEGIN_SRC emacs-lisp
; Backup and auto-save.
(setq
  backup-by-copying t      ; don't clobber symlinks
  backup-directory-alist
   '(("." . "~/.saves"))    ; don't litter my fs tree
  delete-old-versions t
  kept-new-versions 6
  kept-old-versions 2
  version-control t)       ; use versioned backups

(setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
#+END_SRC
** History
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
* Shell
** Launch
#+BEGIN_SRC emacs-lisp
;; Shortcut to launch a shell
(global-set-key (kbd "C-x C-m") 'shell)

;; Open an eshell.
(global-set-key (kbd "C-c e") 'eshell)
#+END_SRC
* Notmuch (emacs email client)
#+BEGIN_SRC emacs-lisp
(use-package notmuch
    :ensure t)

(setq notmuch-poll-script "notmuch-poll")

;; notmuch-hello-mode-map
;; notmuch-search-mode-map
;; notmuch-show-mode-map

;; The delete tag (toggles deleted tag); to actually delete use
;; e.g. the following command: notmuch search --output=files
;; tag:deleted | xargs -l rm (setq debug-on-error t) ;;TODO
(define-key notmuch-search-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

(define-key notmuch-show-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

;; The spam tag (toggles spam tag)
(define-key notmuch-search-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))

(define-key notmuch-show-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))
#+END_SRC
* TODO Ignore-errors configuration
Is this ignore-errors construct necessary? 
#+BEGIN_SRC emacs-lisp
;; These can produce errors when not in GUI mode (i.e. emacs --daemon).
(ignore-errors
  ;; Makes scrolling less jumpy.
  (setq scroll-margin 1
	scroll-conservatively 0
	scroll-up-aggressively 0.01
	scroll-down-aggressively 0.01)
  (setq-default scroll-up-aggressively 0.01
		scroll-down-aggressively 0.01)

  ;; scroll one line at a time (less "jumpy" than defaults)
  ;;  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq scroll-step 1) ;; keyboard scroll one line at a time
)
#+END_SRC
