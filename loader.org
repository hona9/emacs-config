#+TITLE: Emacs configuration using org-mode
#+STARTUP: indent 
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction
GNU Emacs org-mode configuration file. Based on Arjen Wiersma's
[[https://gitlab.com/buildfunthings/emacs-config][emacs-config]] and Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]].

You can find the latest version of this configuration at
[[https://github.com/maridonkers/emacs-config]].

Disclaimer: tested only on Linux, with emacs 25.1.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Mari Donkers")
#+END_SRC
* Installing use-package
** Setup
GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "http://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "http://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "http://stable.melpa.org/packages/"))

;; Add repositories (resetting defaults first).
(setq package-archives nil)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives gnu t)
#+END_SRC

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
(package-initialize)

(unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
             (file-exists-p (concat init-dir "elpa/archives/melpa"))
             (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
        (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+BEGIN_SRC emacs-lisp
(defun packages-install (&rest packages)
  (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC

** The package

#+BEGIN_SRC emacs-lisp
;; Install extensions if they're missing
(defun init--install-packages ()
  (message "Lets install some packages")
  (packages-install
   ;; Since use-package this is the only entry here
   ;; ALWAYS try to use use-package!
   (cons 'use-package melpa)))

(condition-case nil
  (init--install-packages)
  (error (package-refresh-contents)
         (init--install-packages)))
#+END_SRC
* GUI
** Initialization
- Turn off mouse interface early in startup to avoid momentary display.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Cursor
Set cursor color explicitly (?) TODO: investigate why this is required
(the cursor doesn't have the correct color otherwise, for
emacsclient).
#+BEGIN_SRC emacs-lisp
(require 'frame)
(defun set-cursor-hook (frame)
  (modify-frame-parameters frame
                           (list (cons 'cursor-color "#ffff00"))))

(add-hook 'after-make-frame-functions 'set-cursor-hook)
#+END_SRC
** Prerequisite packages
#+BEGIN_SRC emacs-lisp
(require 'cl)
#+END_SRC
** Look and feel
*** Theme
#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
  :ensure t
  :config (load-theme 'cyberpunk t))
#+END_SRC
*** Title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
        '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
#+END_SRC 
*** Desktop
#+BEGIN_SRC emacs-lisp
;; Store desktop (i.e. open files, etc.) at exit (restores when starting again).
(desktop-save-mode 1)
#+END_SRC
*** Ignore error wrapping
#+BEGIN_SRC emacs-lisp
(defun ignore-error-wrapper (fn)
  "Funtion return new function that ignore errors.
   The function wraps a function with `ignore-errors' macro."
  (lexical-let ((fn fn))
    (lambda ()
      (interactive)
      (ignore-errors
        (funcall fn)))))
#+END_SRC
*** Moving around
**** Be sure to just ask for y/n instead of yes/no.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Bookmarks
Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind (("C-c =" . bm-toggle)
         ("C-c [" . bm-previous)
         ("C-c ]" . bm-next)))
#+END_SRC
*** Winner mode
#+BEGIN_SRC emacs-lisp
;; Winner mode
;; From: http://www.emacswiki.org/emacs/WinnerMode
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+END_SRC
*** Window swapping
From [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]].
#+BEGIN_SRC emacs-lisp
;; Initialization of these variables is required.
(setq swapping-buffer nil)
(setq swapping-window nil)

;; First call marks window and after switch to second window call
;; again to swap the windows.
(defun swap-buffers-in-windows ()
   "Swap buffers between two windows"
   (interactive)
   (if (and swapping-window
            swapping-buffer)
       (let ((this-buffer (current-buffer))
             (this-window (selected-window)))
         (if (and (window-live-p swapping-window)
                  (buffer-live-p swapping-buffer))
             (progn (switch-to-buffer swapping-buffer)
                    (select-window swapping-window)
                    (switch-to-buffer this-buffer)
                    (select-window this-window)
                    (message "Swapped buffers."))
           (message "Old buffer/window killed.  Aborting."))
         (setq swapping-buffer nil)
         (setq swapping-window nil))
     (progn
       (setq swapping-buffer (current-buffer))
       (setq swapping-window (selected-window))
       (message "Buffer and window marked for swapping."))))

;; Switch windows.
;;(global-set-key (kbd "C-c C-s") 'transpose-windows)
(global-set-key (kbd "C-c C-s") 'swap-buffers-in-windows)

(global-set-key [f9] 'other-window)
#+END_SRC
*** Window moving
#+BEGIN_SRC emacs-lisp
;; Windmove configuration.
(global-set-key (kbd "C-c <C-left>") (ignore-error-wrapper 'windmove-left))
(global-set-key (kbd "C-c <C-right>") (ignore-error-wrapper 'windmove-right))
(global-set-key (kbd "C-c <C-up>") (ignore-error-wrapper 'windmove-up))
(global-set-key (kbd "C-c <C-down>") (ignore-error-wrapper 'windmove-down))

;;(global-set-key [(control C left)] (ignore-error-wrapper 'windmove-left))
;;(global-set-key [(control C right)] (ignore-error-wrapper 'windmove-right))
;;(global-set-key [(control C up)] (ignore-error-wrapper 'windmove-up))
;;(global-set-key [(control C down)] (ignore-error-wrapper 'windmove-down))
#+END_SRC
*** Window minimize/maximize
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c -") 'minimize-window)
(global-set-key (kbd "C-c +") 'maximize-window)
#+END_SRC
*** Window resizing
#+BEGIN_SRC emacs-lisp
(defun shrink-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window-horizontally 10))

(defun enlarge-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window-horizontally 10))

(defun shrink-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window 10))

(defun enlarge-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window 10))

;; Window resize bindings.
(global-set-key (kbd "C-S-Z <C-S-left>") 'shrink-window-horizontally-stepped)
(global-set-key (kbd "C-S-Z <C-S-right>") 'enlarge-window-horizontally-stepped)
(global-set-key (kbd "C-S-Z <C-S-down>") 'shrink-window-stepped)
(global-set-key (kbd "C-S-Z <C-S-up>") 'enlarge-window-stepped)

(global-set-key (kbd "C-S-C <C-S-left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-S-C <C-S-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-C <C-S-down>") 'shrink-window)
(global-set-key (kbd "C-S-C <C-S-up>") 'enlarge-window)
#+END_SRC
*** Minibuffer
#+BEGIN_SRC emacs-lisp
(defun switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (select-window (active-minibuffer-window))
    (error "Minibuffer is not active")))

;; Switch to minibuffer.
(global-set-key (kbd "C-x M") 'switch-to-minibuffer)
#+END_SRC
*** Swiper
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t)

(use-package counsel
  :ensure t)

(use-package counsel-projectile
  :ensure t
  :config
  (counsel-projectile-on))

(use-package swiper
  :ensure try
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-s" 'swiper)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "C-x C-S-r") 'counsel-recentf)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)))
#+END_SRC
*** Mark
#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

  ;; Mark without select visible.
  (global-set-key (kbd "C-`") 'push-mark-no-activate)
  (global-set-key (kbd "C-~") 'jump-to-mark)
#+END_SRC
*** Tabs
#+BEGIN_SRC emacs-lisp
;; Tab indentation width.
(setq tab-width 4)
#+END_SRC
*** Speedbar
#+BEGIN_SRC emacs-lisp
(global-set-key [f11] 'speedbar)
#+END_SRC
*** Alarm
#+BEGIN_SRC emacs-lisp
;turn off emacs alarms (those annoying beeps)
(setq ring-bell-function 'ignore)
#+END_SRC
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC
** Large files
#+BEGIN_SRC emacs-lisp
;; Large files slow emacs down to a grind. Main offender is fundamental mode.
(defun my-find-file-check-make-large-file-read-only-hook ()
  "If a file is over a given size, make the buffer read only."
  (when (> (buffer-size) (* 1024 1024))
    ;;(setq buffer-read-only t)
    ;;(buffer-disable-undo)
    (fundamental-mode)))

(add-hook 'find-file-hook 'my-find-file-check-make-large-file-read-only-hook)
#+END_SRC
* Org-mode
Org-mode is an Emacs built-in.
** Shortcuts
#+BEGIN_SRC emacs-lisp
;;TODO
;;(require 'org)
;;(define-key global-map "\C-cl" 'org-store-link)
;;(define-key global-map "\C-ca" 'org-agenda)
;;(setq org-log-done t)
#+END_SRC
** Indentation
#+BEGIN_SRC emacs-lisp
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
** HTMLize buffers
When exporting documents to HTML documents, such as code fragments, we need to htmlize.
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC
** Reveal.js
Tool to create presentations via an emacs org file export. See
[[http://matt.hackinghistory.ca/2015/07/11/creating-and-publishing-presentations-with-org-reveal/][Creating and Publishing Presentations with org-reveal]].
#+BEGIN_SRC emacs-lisp
;;TODO doesn't appear to work (breaks org-mode export of title sections).
;;(use-package ox-reveal
;;    :ensure ox-reveal)

;; Reveal.js location and ox-reveal.
;;(setq org-reveal-root "file:///home/mdo/lib/reveal.js")
;;(setq org-reveal-mathjax t)
#+END_SRC 
* Markdown
Markdown is a great way to write documentation, not as good as
org-mode of course, but generally accepted as a standard.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC
* LaTex
#+BEGIN_SRC emacs-lisp
(use-package tex
    :ensure auctex
    :config (setq TeX-auto-save t)
            (setq TeX-parse-self t)
            (setq TeX-save-query nil))
;;(setq TeX-PDF-mode t)
(require 'tex)
#+END_SRC
* Programming
** General
Setup for GNU Emacs, Clojure and ClojureScript. Plus [[https://github.com/Fuco1/smartparens][Smartparens]].

The structured editing of smartparens is useful in a LOT of languages, as
long as there are parenthesis, brackets or quotes.
*** Utilities
String manipulation routines for emacs lisp
#+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
#+END_SRC
*** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config (progn (show-smartparens-global-mode t))
                 (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-strict-mode)
                 (add-hook 'ielm-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-interaction-mode-hook #'smartparens-strict-mode)
                 (add-hook 'scheme-mode-hook #'smartparens-strict-mode)
  :bind (("<f7>" . smartparens-strict-mode)
         ("C-S-s a" . sp-beginning-of-sexp)
         ("C-S-s e" . sp-end-of-sexp)
         ("C-S-s d" . sp-down-sexp)
         ("C-S-s u" . sp-up-sexp)
         ("C-S-s D" . sp-backward-down-sexp)
         ("C-S-s U" . sp-up-down-sexp)
         ("C-S-s f" . sp-forward-sexp)
         ("C-S-s b" . sp-backward-sexp)
         ("C-M-<right>" . sp-next-sexp)
         ("C-M-<left>" . sp-previous-sexp)
         ("C-S-s S" . sp-backward-symbol)
         ("C-S-s s" . sp-forward-symbol)
         ("C-S-s |" . sp-split-sexp)
         ("C-S-s U" . sp-backward-unwrap-sexp)
         ("C-S-s u" . sp-unwrap-sexp)
         ("M-<right>" . sp-forward-slurp-sexp)
         ("M-S-<right>" . sp-forward-barf-sexp)
         ("M-<left>" . sp-backward-slurp-sexp)
         ("M-S-<left>" . sp-backward-barf-sexp)
         ("C-S-s t" . sp-transpose-sexp)
         ("C-S-s k" . sp-kill-sexp)
         ("C-S-s h" . sp-kill-hybrid-sexp)
         ("C-S-s K" . sp-backward-kill-sexp)))
#+END_SRC
*** Highlight parentheses
#+BEGIN_SRC emacs-lisp
(use-package highlight-parentheses
  :ensure t
  :diminish highlight-parentheses-mode
  :config (add-hook 'emacs-lisp-mode-hook
            (lambda() (highlight-parentheses-mode))))

(global-highlight-parentheses-mode)
#+END_SRC
*** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config (add-hook 'lisp-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojure-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojurec-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojurescript-mode-hook
              (lambda() (rainbow-delimiters-mode))))

(global-highlight-parentheses-mode)
#+END_SRC

*** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas
  :config (yas/global-mode 1)
          (add-to-list 'yas-snippet-dirs (concat init-dir "snippets")))

(use-package clojure-snippets
  :ensure t)
#+END_SRC

*** Auto completion
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :bind (("C-c /". company-complete))
  :config (global-company-mode))

;;  (use-package company-flx
;;    :ensure t
;;    :config (with-eval-after-load 'company
;;            (company-flx-mode +1)))
#+END_SRC

*** Code folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :config (global-origami-mode)
  :bind (("C-c |" . origami-reset)
         ("C-c {" . origami-open-node-recursively)
         ("C-c }" . origami-close-node-recursively)
         ("C-c \"" . origami-toggle-all-nodes)))
#+END_SRC
*** Version Control
Magit is the only thing you need when it comes to Version Control (Git)

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
;; Project based navigation and search. Note also the .projectile file that
;; can be placed in the root of a project. It can be used to exclude (or include)
;; directories (see: https://github.com/bbatsov/projectile).
(use-package projectile
  :ensure t)

(projectile-global-mode)
#+END_SRC
*** REST (client) support
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t)
#+END_SRC

*** Imenu
#+BEGIN_SRC emacs-lisp
;; Add imenu to menu bar and make it automatically rescan.
(add-hook 'clojure-mode-hook #'imenu-add-menubar-index)
(add-hook 'clojurec-mode-hook #'imenu-add-menubar-index)
(add-hook 'clojurescript-mode-hook #'imenu-add-menubar-index)
(setq imenu-auto-rescan 1)

;; Incremental imenu.
(global-set-key (kbd "C-S-l") 'imenu)
#+END_SRC
*** Symbols
**** Highlight s-exp
#+BEGIN_SRC emacs-lisp
(use-package hl-sexp
  :ensure t
  :config (add-hook 'lisp-mode-hook #'hl-sexp-mode)
          (add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode) 
  :bind (("C-M-'" . hl-sexp-mode)))
#+END_SRC
**** Highlight symbol
#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :config (highlight-symbol-mode 1)
          (setq highlight-symbol-idle-delay  0.5)
  :bind (("C-*" . highlight-symbol)
         ("M-*" . highlight-symbol-remove-all)
         ("<f5>" . highlight-symbol-next)
         ("S-<f5>" . highlight-symbol-prev)
         ("M-<f5>" . highlight-symbol-query-replace)))
#+END_SRC
** Clojure
The clojure ecosystem for GNU Emacs consists out of CIDER and bunch of
supporting modules.
*** Cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :pin melpa-stable
  :config (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
          (add-hook 'cider-repl-mode-hook #'company-mode)
          (add-hook 'cider-mode-hook #'company-mode)
          (add-hook 'cider-mode-hook #'eldoc-mode)            
          (setq cider-repl-history-file "~/.emacs.d/cider-history")
          (setq cider-repl-use-clojure-font-lock t)
          (setq cider-repl-result-prefix ";; => ")
          (setq cider-repl-wrap-history t)
          (setq cider-repl-history-size 9999)
          (setq cider-repl-use-pretty-printing t)
          (setq cider-repl-display-help-banner nil)
          (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")
  :bind (("M-r" . cider-namespace-refresh)
         ("C-c r" . cider-repl-reset)
         ("C-c ." . cider-reset-test-run-tests)
         ("M-<return>" . cider-doc)
         ("<f8>" . cider-clear-compilation-highlights)))

(add-hook 'clojure-mode-hook #'smartparens-strict-mode)
(add-hook 'clojurec-mode-hook #'smartparens-strict-mode)
(add-hook 'clojurescript-mode-hook #'smartparens-strict-mode)
#+END_SRC
*** Expand region
#+BEGIN_SRC emacs-lisp
;expand-region functionality is really great for lisp/clojure editing
;from https://github.com/magnars/expand-region.el
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region))
#+END_SRC
* Editing
** Navigation and S-exp
#+BEGIN_SRC emacs-lisp
;; Delete sexp.
(global-set-key (kbd "<C-S-delete>") 'kill-sexp)

;; Goto previous top level paren-block.
(global-set-key (kbd "M-p") 'outline-previous-visible-heading)
(global-set-key (kbd "M-n") 'outline-next-visible-heading)

;; C-arrow for word navigation.
(global-set-key (kbd "<C-left>") 'left-word)
(global-set-key (kbd "<C-right>") 'right-word)
#+END_SRC
** Lines
*** Selecting
#+BEGIN_SRC emacs-lisp
(defun select-current-line ()
  "Select current line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2015-02-07
"
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))

;; Select current line.
(global-set-key (kbd "C-|") 'select-current-line)
#+END_SRC
*** Joining
#+BEGIN_SRC emacs-lisp
(defun join-next-line ()
  "Join next line."
  (interactive)
  (forward-line 1)
  (join-line))

;; Join line.
(global-set-key (kbd "C-S-J") 'join-next-line)
#+END_SRC
*** Deleting
#+BEGIN_SRC emacs-lisp
(defun delete-line-or-region (&optional n)
  "Delete current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
	(delete-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
	(delete-region (line-beginning-position) (line-end-position))
	(kill-whole-line)))))

;; Delete region.
(global-set-key (kbd "C-S-D") 'delete-line-or-region)
(global-set-key (kbd "<M-delete>") 'delete-line-or-region)
#+END_SRC
*** TODO Commenting
Check out commenter package.
#+BEGIN_SRC emacs-lisp
(defun comment-line-or-region (&optional n)
  "Comment current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
	(comment-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
	(comment-region (line-beginning-position) (line-end-position))))))

;; Comment current line or region.
(global-set-key (kbd "C-;") 'comment-line-or-region)
#+END_SRC
*** Move-dup
#+BEGIN_SRC emacs-lisp
(use-package move-dup
  :ensure t)

(global-move-dup-mode)
#+END_SRC
*** Truncating
#+BEGIN_SRC emacs-lisp
;; Disable line truncating by default (normally buffer local setting)
(set-default 'truncate-lines t)
#+END_SRC
*** Numbering
#+BEGIN_SRC emacs-lisp
;; No line numbers by default.
(global-linum-mode 0)
(set-default 'global-linum-mode 0)

;; Line numbers for various source file types.
(add-hook 'html-mode-hook (lambda () (linum-mode 1)))
(add-hook 'c-mode-hook (lambda () (linum-mode 1)))
(add-hook 'clojure-mode-hook (lambda () (linum-mode 1)))
(add-hook 'clojurec-mode-hook (lambda () (linum-mode 1)))
(add-hook 'clojurescript-mode-hook (lambda () (linum-mode 1)))
#+END_SRC

*** Various
#+BEGIN_SRC emacs-lisp
;; Quick switch linum-mode.
(global-set-key (kbd "C-S-n") 'linum-mode)

;; Expand and replace region.
(global-set-key (kbd "C-$") 'expand-delete-line)

;; Turn off text wrapping in the middle of a word
(global-visual-line-mode 1)
#+END_SRC
** Change
*** Goto last change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure t)

(global-set-key (kbd "C-S-Q") 'goto-last-change)
#+END_SRC
*** Undo tree
#+BEGIN_SRC emacs-lisp
;; Adds a custom directory where some .el scripts are placed used in
;; this config file. Note that if you have .el scripts that exist on
;; Melpa, you don't need this directory. But I have an undo-tree
;; script (configured below) not on Melpa, so this is how you do it:
(add-to-list 'load-path (concat user-emacs-directory "macros-config"))

;; From http://www.emacswiki.org/emacs/UndoTree Script must exist in
;; the macros-config directory before proceeding (see above paragraph)
(use-package undo-tree
  :ensure t)

;;TODO
;;(global-undo-tree-mode)

;; Replace regular undo and redo with respectively tree-undo and tree-redo.
(global-set-key (kbd "C-_") 'undo-tree-undo)
(global-set-key (kbd "C-/") 'undo-tree-undo)
(global-set-key (kbd "M-_") 'undo-tree-redo)
(global-set-key (kbd "C-?") 'undo-tree-redo)

;; Undo tree visualize
(global-set-key (kbd "C-x u") 'undo-tree-visualize)
#+END_SRC
** Parenthesis
*** Matching
Emacs lisp code from: [[https://www.emacswiki.org/emacs/NavigatingParentheses][Navigating Parentheses]].
#+BEGIN_SRC emacs-lisp
(defun goto-match-paren (arg)
  "Go to the matching parenthesis if on parenthesis. Else go to the
   opening parenthesis one level up."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1))
	(t
	 (backward-char 1)
	 (cond ((looking-at "\\s\)")
		(forward-char 1) (backward-list 1))
	       (t
		(while (not (looking-at "\\s("))
		  (backward-char 1)
		  (cond ((looking-at "\\s\)")
			 (message "->> )")
			 (forward-char 1)
			 (backward-list 1)
			 (backward-char 1)))
		  ))))))

(global-set-key (kbd "C-S-P") 'goto-match-paren)
#+END_SRC
** Whitespaces
#+BEGIN_SRC emacs-lisp
;; Trim trailing whitespaces in current buffer.
(global-set-key (kbd "C-S-W") 'delete-trailing-whitespace)
#+END_SRC
** Search
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-S-F") 'find-dired)
(global-set-key (kbd "C-%") 'replace-string)

;; Recursive grep to e.g. find all references of an entered string
(global-set-key (kbd "C-,") 'rgrep)

(use-package ag
  :ensure t)
#+END_SRC
** Scroll
#+BEGIN_SRC emacs-lisp
;; Scroll without changing point.
(global-set-key (kbd "C-<") 'scroll-up-line)
(global-set-key (kbd "C->") 'scroll-down-line)
#+END_SRC
** Backup
#+BEGIN_SRC emacs-lisp
; Backup and auto-save.
(setq
  backup-by-copying t      ; don't clobber symlinks
  backup-directory-alist
   '(("." . "~/.saves"))    ; don't litter my fs tree
  delete-old-versions t
  kept-new-versions 6
  kept-old-versions 2
  version-control t)       ; use versioned backups

(setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
#+END_SRC
** History
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
* Shell
** Launch
#+BEGIN_SRC emacs-lisp
;; Shortcut to launch a shell
(global-set-key (kbd "C-x C-m") 'shell)

;; Open an eshell.
(global-set-key (kbd "<f12>") 'eshell)
#+END_SRC
* Notmuch (emacs email client)
#+BEGIN_SRC emacs-lisp
(use-package notmuch
    :ensure t)

(setq notmuch-poll-script "notmuch-poll")

;; notmuch-hello-mode-map
;; notmuch-search-mode-map
;; notmuch-show-mode-map

;; The delete tag (toggles deleted tag); to actually delete use
;; e.g. the following command: notmuch search --output=files
;; tag:deleted | xargs -l rm (setq debug-on-error t) ;;TODO
(define-key notmuch-search-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

(define-key notmuch-show-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

;; The spam tag (toggles spam tag)
(define-key notmuch-search-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))

(define-key notmuch-show-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))
#+END_SRC
* Ignore-errors configuration
#+BEGIN_SRC emacs-lisp
;; These can produce errors when not in GUI mode (i.e. emacs --daemon).
(ignore-errors
  ;; Makes scrolling less jumpy.
  (setq scroll-margin 1
	scroll-conservatively 0
	scroll-up-aggressively 0.01
	scroll-down-aggressively 0.01)
  (setq-default scroll-up-aggressively 0.01
		scroll-down-aggressively 0.01)

  ;; scroll one line at a time (less "jumpy" than defaults)
  ;;  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq scroll-step 1) ;; keyboard scroll one line at a time

  ;; Font and size.
  (toggle-use-system-font)
  (set-face-attribute 'default nil :height 135)

  ;; Selection color.
  ;;(set-face-background 'hl-line "#3e4446")
  ;; (set-face-foreground 'highlight nil)

  ;; Font size
  (define-key global-map (kbd "C-c C-=") 'text-scale-increase)
  (define-key global-map (kbd "C-c C--") 'text-scale-decrease)

  ;; Clearer active window bar.
  (set-face-attribute  'mode-line-inactive
                        nil 
                        :foreground "white"
                        :background "#232323"
                        ;; :box '(:line-width 1 :style released-button)
                        :box nil)

  (set-face-attribute  'mode-line
                        nil 
                        :foreground "black"
                        :background "darkcyan"
                        ;; :box '(:line-width 1 :style released-button)
                        :box nil)

  ;; Via custom themes; see init.et...
  ;; (load-theme 'cyberpunk)

  ;; No boxes around mode line (cyberpunk theme creates these).
  ;;(set-face-attribute `mode-line nil :box nil)
  ;;(set-face-attribute `mode-line-inactive nil :box nil)

  ;; Set cursor color, shape and no blinking.
  (setq-default cursor-color "#ffff00")
  (set-cursor-color "#ffff00")
  (setq-default cursor-type 'hollow)
  (blink-cursor-mode 0))
#+END_SRC
